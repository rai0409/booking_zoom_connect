You are a senior SaaS engineer. Implement a “commercial MVP-quality” scheduling/booking system in TypeScript. Output MUST be “GitHub-ready”: monorepo, Docker, .env.example, README, Prisma migrations, minimal tests. The output format is strict: repo tree first, then every file in full separated by `FILE: path`. If too large, split into (1/3)(2/3)(3/3) with no missing files.

# Purpose
Expose multiple salespeople’s Outlook availability to customers. When a customer books (after email verification), the system automatically:
1) creates a Zoom meeting,
2) creates an Outlook calendar event (customer as attendee),
3) sends the meeting invitation email (= booking confirmation).
Assume frequent manual changes in Outlook; keep synchronization via Microsoft Graph change notifications (webhooks). Persist analytics events (booking completion rate / cancellation rate / attendance rate). Multi-tenant: each customer connects their own Microsoft 365/Entra tenant with admin consent.

# Fixed Requirements (must not change)
- Cloud: Azure. Deployment target: Azure Container Apps (need min replicas=1 for webhook responsiveness).
- Backend: Node.js + TypeScript (NestJS preferred).
- Frontend: Next.js (minimal booking UI).
- DB: Postgres.
- Queue: Azure Service Bus in production. Local dev uses in-memory queue (interface swappable).
- Secrets: Key Vault in prod; local uses .env.
- Observability: App Insights in prod; local uses console.
- Microsoft Graph: app-only (application permissions). Multi-tenant app requiring admin consent per tenant.
- Tenant isolation: single DB with tenant_id column separation.
- Email sending:
  - Booking invitation/confirmation = Outlook event created via Graph in salesperson calendar (customer as attendee).
  - Email verification + auxiliary emails = Graph sendMail from a shared mailbox.
- Meetings: Zoom (paid assumed). Zoom meetings are created under OUR Zoom org host (customer does not connect their Zoom).
- Booking finalization: only after customer clicks email verification link.
- Cancel/reschedule: customer self-service with deadline (default: allowed until 24h before start).
- Attendance: salesperson records attended/no_show via one-click endpoint (auto meeting logs deferred).
- Scale: ~15 salespersons, up to 30 bookings/day, peak 10–20/hour, retention 1 year.

# Reliability (critical)
- Graph webhook must respond quickly: return 200/202 within 10 seconds. Heavy processing MUST be enqueued and processed by a worker.
- Idempotency: /holds, /confirm, /cancel, /reschedule must support Idempotency-Key header; prevent duplicates via DB unique constraints.
- Saga/compensation: handle cases like Zoom success but Graph failure. Provide minimal retry + compensation jobs.
- Throttling: respect Retry-After for Graph 429/503 with exponential backoff and jitter.

# Monorepo
- /apps/web : Next.js (booking UI)
- /apps/api : NestJS (REST API + webhook receiver + worker)
- /packages/shared : DTOs (zod), utils, auth helpers
- Prisma for schema + migrations.
- Docker Compose for local Postgres.
- Use pnpm workspaces + Turbo (or Nx) for dev scripts.

# Multi-tenant onboarding flow (MUST implement, do not leave ambiguous)
We use ONE multi-tenant Entra application (client_id + client_secret are shared globally; do NOT store per-tenant secrets). For each tenant:
- `POST /v1/tenants/connect`:
  - input: { tenant_name, tenant_slug }
  - creates a tenants row with status="pending"
  - returns an admin consent URL for Microsoft Entra: /adminconsent?client_id=...&redirect_uri=...&state=...
- `GET /v1/tenants/callback`:
  - handles Entra admin consent redirect
  - reads tenant ID from the callback (store into tenants.m365_tenant_id)
  - marks tenants.status="active"
  - also initiates Graph subscriptions creation for all salespersons belonging to this tenant (or provides a job to do so)
- Token acquisition:
  - For Graph calls, obtain an app-only token using client_credentials against tenant’s authority using tenants.m365_tenant_id.
  - Cache tokens in-memory with exp; refresh as needed.

# Tenant model
- tenants has: id (uuid), name, slug (unique), m365_tenant_id (nullable until connected), status [pending|active|disabled], created_at
- All API requests must provide tenant context via:
  - tenant_id in body OR tenant_slug in URL, then resolved to tenant_id, AND checked consistently.

Continue in Part 2 with: data model, state machine, DB constraints/locking, REST API details.
Continue from Part 1.

# Timezone rule (MUST implement)
- Persist all timestamps in DB as UTC (timestamptz).
- Client/UI displays times in tenant default timezone (tenant_config) or salesperson.timezone.
- When creating Zoom/Graph events, include explicit timezone strings (IANA where supported). Convert from UTC for provider calls.
- All API inputs accept ISO8601 with timezone; normalize to UTC immediately.

# Data model (Prisma)
Implement these tables exactly (add missing necessary fields too):
- tenants(id, name, slug, m365_tenant_id, status, created_at)
- salespersons(id, tenant_id, graph_user_id, display_name, timezone, active)
- customers(id, tenant_id, name, email, company)
- bookings(
    id, tenant_id, salesperson_id, customer_id,
    start_at_utc, end_at_utc,
    status [hold|pending_verify|confirmed|canceled|expired],
    idempotency_key,
    verify_token_jti (nullable),
    created_at, updated_at
  )
- holds(booking_id, expires_at_utc)
- meetings(booking_id, provider [zoom|teams], provider_meeting_id, join_url, start_url, created_at)
- graph_events(booking_id, organizer_user_id, event_id, iCalUId, etag, updated_at)
- tracking_events(id, tenant_id, booking_id, type, occurred_at_utc, meta_json)
- audit_logs(id, tenant_id, actor_type, actor_id, action, target_type, target_id, meta_json, created_at_utc)
- webhook_jobs(id, tenant_id, salesperson_id, subscription_id, change_type, resource_id, received_at_utc, status, attempts, last_error, created_at_utc)

# Booking state machine (MUST implement as a table in README + enforce in code)
States:
- hold: created by /holds; has holds.expires_at_utc (TTL 10m). Not yet verified.
- pending_verify: verification email sent; verify token is valid until hold expiration (or a separate short TTL, e.g., 15m).
- confirmed: Zoom + Graph event created, customer invited.
- canceled: explicitly canceled by customer before deadline.
- expired: TTL passed before confirmation; system auto-expires.

Transitions:
- (none) -> hold (POST /holds)
- hold -> pending_verify (POST /auth/verify-email)
- hold|pending_verify -> expired (TTL worker)
- pending_verify -> confirmed (POST /confirm with valid token, before expires)
- confirmed -> canceled (POST /bookings/:id/cancel before deadline)
- confirmed -> hold (reschedule flow: cancel then create new hold)
Rules:
- If hold expires, confirm must fail with 409 and mark expired.
- Only one “active booking” per (tenant_id, salesperson_id, start_at_utc, end_at_utc) is allowed where active = {hold,pending_verify,confirmed}. Expired/canceled do not block.
- Confirm is a saga: create Zoom -> create Graph -> persist both -> set booking confirmed. Must be idempotent.

# DB constraints & locking (MUST implement to prevent double-booking)
- Add a UNIQUE constraint to enforce active-slot uniqueness. Use a partial unique index in Postgres:
  UNIQUE (tenant_id, salesperson_id, start_at_utc, end_at_utc) WHERE status IN ('hold','pending_verify','confirmed')
- Add UNIQUE on bookings.idempotency_key per tenant: UNIQUE(tenant_id, idempotency_key)
- Use transactions for hold/confirm/cancel/reschedule.
- If Prisma cannot express partial unique index cleanly, include a SQL migration with `CREATE UNIQUE INDEX ... WHERE ...`.
- Additionally, during confirm, acquire an advisory lock keyed by booking_id to prevent concurrent confirm attempts:
  pg_advisory_xact_lock(hashtext(booking_id)) (or bigint hash) within the transaction.

# REST API (/v1) - implement exactly
Tenant resolution:
- For public pages use tenant_slug in URL: /v1/public/:tenantSlug/...
- For internal calls allow tenant_id, but public endpoints must primarily use tenant_slug.

Endpoints:
1) GET /v1/public/:tenantSlug/availability?salesperson=...&date=YYYY-MM-DD
   - Generate 60-min slots (default) with buffer +/- 10 min.
   - Read Graph calendar busy times for salesperson.graph_user_id.
   - Cache per (tenant_id, salesperson_id, date) for 30–60 seconds.

2) POST /v1/public/:tenantSlug/holds
   - Headers: Idempotency-Key required
   - body: { salesperson_id, start_at, end_at, customer: { email, name?, company? } }
   - Normalize times to UTC.
   - Create/Upsert customer by (tenant_id, email).
   - Create booking status=hold + holds row expires_at_utc=now+10m.
   - On uniqueness conflict (slot already active), return 409.

3) POST /v1/public/:tenantSlug/auth/verify-email
   - Headers: Idempotency-Key required
   - body: { booking_id }
   - If booking is hold and not expired:
     - generate short-lived JWT verify token (exp <= holds.expires_at_utc)
     - include jti; store verify_token_jti in bookings
     - send email from shared mailbox with link:
       `${BASE_URL}/verify?token=...`
     - set status=pending_verify
   - If already pending_verify and token not expired, re-send same token (idempotent).
   - If expired, mark expired and return 409.

4) POST /v1/public/:tenantSlug/confirm
   - Headers: Idempotency-Key required
   - body: { token }
   - Verify JWT (iss/aud/exp), extract tenant_id, booking_id, jti.
   - Enforce one-time use:
     - compare jti with bookings.verify_token_jti
     - mark token as consumed by clearing verify_token_jti (or storing consumed_jti table)
   - Confirm saga within transaction + advisory lock:
     a) create Zoom meeting (retry on transient errors)
     b) create Graph event with attendees including customer.email, include booking_id + join_url in subject/body/location
     c) persist meetings + graph_events rows
     d) set booking status=confirmed
     e) write tracking_events + audit_logs
   - If Zoom succeeded but Graph failed: record a compensation task (e.g., a “compensation_jobs” table or reuse webhook_jobs), and attempt to delete Zoom meeting best-effort.

5) POST /v1/public/:tenantSlug/bookings/:id/cancel
   - Headers: Idempotency-Key required
   - body: { token }  (JWT for cancel; same security rules)
   - Validate deadline: now <= start_at_utc - 24h
   - Cancel Graph event (delete or cancel) + delete Zoom meeting best-effort
   - Set booking status=canceled, write tracking/audit.
   - If already canceled, return 200 (idempotent).

6) POST /v1/public/:tenantSlug/bookings/:id/reschedule
   - Headers: Idempotency-Key required
   - body: { token, new_start_at, new_end_at }
   - Validate deadline for cancel.
   - Implement minimal: cancel old booking then create new hold and send verify email in same call OR return new booking_id and require verify-email call.
   - Ensure idempotency & slot uniqueness.

7) POST /v1/internal/attendance/:bookingId
   - Header: X-Admin-Api-Key required; also tenant scope required via header X-Tenant-Id or booking’s tenant_id must match key scope.
   - body: { status: 'attended'|'no_show' }
   - Write tracking_event + audit_log.

8) POST /v1/webhooks/graph
   - If query has validationToken, return it as plain text immediately.
   - Otherwise:
     - parse notifications
     - respond 202 within 10 seconds
     - enqueue each notification into queue as webhook job with schema defined in Part 3.

Continue in Part 3 with: queue payload schema, worker behavior, Graph subscription renewal, Outlook manual-change policy, security (JWT aud/iss/exp + one-time jti), local dev, tests, and Azure Container Apps deployment notes.
Continue from Parts 1–2.

# Webhook queue payload schema (MUST be explicit and used across receiver/worker)
Define a shared TypeScript type + zod schema:
GraphWebhookJobPayload = {
  tenant_id: string,
  salesperson_id: string,
  subscription_id: string,
  change_type: string,          // created|updated|deleted (or resourceData.changeType when available)
  resource_id: string,          // eventId (extract from resource or resourceData.id)
  received_at_utc: string       // ISO8601 UTC
}

# Worker responsibilities (MUST implement)
- Dequeue GraphWebhookJobPayload.
- Fetch latest event details from Graph for that tenant + salesperson.
- Reconcile with DB:
  - locate booking by graph_events.event_id OR by booking_id embedded in event body/subject (fallback).
  - if event moved (start/end changed) and booking is confirmed:
    - update bookings.start_at_utc/end_at_utc to match Graph
    - write tracking_events type="event_moved_by_sales" + audit_log
    - DO NOT email customer in v1.0; instead record a tracking_event "customer_reinvite_required" with meta.
  - if event deleted/canceled and booking is confirmed:
    - set booking status=canceled (source="sales_manual")
    - write tracking/audit
    - DO NOT email customer in v1.0; record tracking_event "customer_notify_required".
- Idempotency: webhook jobs must be safe to retry. Store attempts and last_error in webhook_jobs table.
- Backoff: retry failed jobs with exponential backoff; cap attempts (e.g., 10). Dead-letter to webhook_jobs.status="dead".

# Outlook manual-change policy (MUST be explicit)
v1.0 policy:
- Manual move of confirmed event => booking follows organizer’s calendar change (DB updated), but customer is NOT automatically re-invited; system flags it for manual follow-up (tracking events).
- Manual deletion of confirmed event => booking is canceled; system flags customer notification required.
This avoids accidental customer spam and keeps “truth” aligned with salesperson calendar.

# Graph subscriptions (MUST implement minimal renewal)
- Provide a scheduled job (cron) that:
  - for each active tenant + active salesperson:
    - ensures a valid events subscription exists
    - renews subscription before expiration
- Store subscription metadata in DB:
  - graph_subscriptions(id, tenant_id, salesperson_id, subscription_id, resource, expiration_utc, created_at_utc, updated_at_utc)
- Webhook URL = `${BASE_URL}/v1/webhooks/graph`.
- If subscription creation fails, write audit_logs + keep retrying.

# Token caching
- Implement per-tenant token cache in API process:
  - key: tenant.m365_tenant_id
  - value: { access_token, expires_at_utc }
- Always refresh before expiry (e.g., 60s early).

# Zoom S2S OAuth
- Implement token fetch + cache.
- Create meeting with timezone specified.
- Persist join_url/start_url/provider_meeting_id.

# Security hardening (MUST implement)
JWT tokens (verify/cancel/reschedule):
- include: iss, aud, exp, jti, tenant_id, booking_id, purpose
- verify:
  - iss must equal BASE_URL
  - aud must equal "booking-system"
  - exp must be short (<= hold expiry or <= 24h for cancel/reschedule links)
- one-time use:
  - store verify token jti in bookings.verify_token_jti
  - on confirm, compare and then clear/consume
- For cancel/reschedule tokens, allow multi-use but include jti and store in a token_consumptions table if one-time is desired; for MVP, require exp short and include booking_id.
Attendance API:
- Must require admin API key AND tenant scoping.
- Admin key stored in env; later replace with proper auth.

# Local dev
- docker compose: postgres
- pnpm dev: starts api + web
- Provide seed script:
  - create a tenant with slug
  - create 1–2 salespersons with graph_user_id placeholders
- Provide "mock mode":
  - if GRAPH_MOCK=true, return deterministic availability and skip real Graph calls
  - if ZOOM_MOCK=true, return deterministic join_url

# Tests (minimum)
- hold idempotency + unique slot conflict
- confirm saga:
  - happy path (mock zoom + mock graph)
  - graph failure triggers compensation record
- webhook receiver enqueues and returns fast

# README must include
- Local setup + env vars
- How to register Entra multi-tenant app and obtain admin consent (high-level steps)
- How to set application permissions required for Graph
- Zoom S2S OAuth setup steps (high-level)
- Azure Container Apps deploy steps:
  - build/push container
  - create container app
  - set env vars
  - set min replicas=1 for webhook responsiveness
- Provide an example az CLI snippet or Bicep fragment for min replicas=1.

# Final deliverable rules (strict)
- Provide repo tree, then all files separated by FILE markers.
- No missing files. No placeholders like “TODO: implement later” for the required flows; stubs are only allowed for optional parts.
